var t=require("@collectable/red-black-tree"),e=t.fromPairsWithStringKeys,s=t.iterateFromFirst,i=t.iterateValuesFromLast,n=t.remove,a=t.set,r=t.size,o=t.valueAt,h=w(require("@babel/runtime/helpers/classPrivateFieldSet")),l=w(require("@babel/runtime/helpers/classPrivateFieldGet")),c=w(require("pouchdb-find")),d=w(require("pouchdb")),u=w(require("@babel/runtime/helpers/defineProperty"));function w(t){return t&&t.__esModule?t.default:t}require("regenerator-runtime/runtime");var m,p=!1;function v(){return p||(p=!0,m={},m=Promise.resolve(require("./crypto.942fa222.js"))),m}const y="undefined"!=typeof crypto&&void 0!==crypto.getRandomValues?async function(t){return crypto.getRandomValues(t)}:async function(t){if(!(t instanceof Uint8Array))throw new Error("The getRandomValues() shim only takes unsigned 32-bit int arrays");var e=(await v()).randomBytes(t.length);return t.set(e),t};function f(t){const e=new Uint8Array(t);return Array.prototype.slice.call(e).map(t=>("00"+t.toString(16)).slice(-2)).join("")}const g=RegExp("a_[0-9]{14}_[0-9a-f]{8}");async function S(t){const e=`a_${t.toString().padStart(14,"0")}_${f(await y(new Uint8Array(4)))}`;if(s=e,!g.test(s))throw new Error("internal error: generated an invalid attempt UUID: "+e);var s;return e}const b=RegExp("s_[0-9a-f]{8}");async function _(t){const e="s_"+f(await y(new Uint8Array(8)));if(s=e,!b.test(s))throw new Error("internal error: generated an invalid attempt UUID: "+e);var s;return e}function M(t){return"totalResultMs"in t}function D(t){return"name"in t&&"event"in t}d.plugin(c);class A{constructor(){u(this,"localDB",void 0),u(this,"remoteDB",null),u(this,"sync",void 0),u(this,"listeners",[]),this.localDB=new d("timer_db_default"),this.localDB.createIndex({index:{fields:["sessionID"]}})}connectRemoteDB(t,e){const s=new URL("https://couchdb.api.cubing.net/");s.username=t,s.password=e,s.pathname="results-"+localStorage.timerDBUsername;const i=s.toString();this.remoteDB=new d(i),this.sync=this.localDB.sync(this.remoteDB,{live:!0,retry:!0}),this.sync.on("change",this.onSyncChange.bind(this)),this.sync.on("error",this.onSyncError.bind(this))}addListener(t){this.listeners.push(t)}removeListener(t){for(let e=0;e<this.listeners.length;e++)if(this.listeners[e]===t)return void(this.listeners=this.listeners.slice(0,e).concat(this.listeners.slice(e+1)));throw new Error("Tried to remove a sync change listener that wasn't registered!")}onSyncChange(t){for(const e of this.listeners)e(t.change.docs)}onSyncError(t){console.error("timer-db sync error",t)}async addNewAttempt(t){if(!M(t))throw new Error("Attempted to store invalid attempt data");const e=t;e._id=await S(t.unixDate);const s=await this.localDB.put(e);if(!s.ok)throw new Error("Could not add attempt to session");return e._rev=s.rev,e}async updateAttempt(t){await this.localDB.put(t)}async deleteAttempt(t){await this.localDB.remove(t)}async latestAttempts(t,e){return(await this.localDB.find({limit:e,selector:{sessionID:t},sort:[{_id:"desc"}]})).docs.map(t=>(M(t)||console.error("WARNING: Invalid attempt in database!",t),t))}async createSession(t){if(!D(t))throw new Error("Attempted to store invalid attempt data");const e=t;e._id=await _(t.name);const s=await this.localDB.put(e);if(!s.ok)throw new Error("Could not add attempt to session");return e._rev=s.rev,e}async getAllSessions(){return(await this.localDB.allDocs({include_docs:!0,startkey:"s_",endkey:"s_ï¿°"})).rows.map(t=>{const e=t.doc;var s;return D(s=e)&&"_rev"in s||console.error("WARNING: Invalid attempt in database!",e),e})}async sessionNumAttempts(t){return(await this.localDB.find({fields:[],selector:{sessionID:t}})).docs.length}}class R{constructor(t,e,s=100,i=s+25,n=s+50){if(this.storage=t,this.sessionID=e,this.minSize=s,this.midSize=i,this.maxSize=n,u(this,"latestSolves",void 0),s>i||i>n)throw new Error("AttemptCache initialized with invalid size parameters.");if(this.minSize>1e3)throw new Error("AttemptCache min size is capped at 1000");if(this.maxSize>1050)throw new Error("AttemptCache max size is capped at 1050.");this.latestSolves=this.getLatestFromDB(this.midSize)}async getLatestFromDB(t){const s=(await this.storage.latestAttempts(this.sessionID,t)).map(t=>[t._id,t]);return e(s)}growToMidSize(t){return this.getLatestFromDB(this.midSize)}shrinkToMidSize(t){const s=[];let n=0;for(const e of i(t))if(s.push([e._id,e]),n++,n>=this.midSize)break;return Promise.resolve(e(s))}async maintainSize(t){const e=await r(t);return e<this.minSize?this.growToMidSize(t):e>this.maxSize?this.shrinkToMidSize(t):t}async debugCurrentSize(){return r(await this.latestSolves)}async debugPrint(){const t=[];for(const e of s(await this.latestSolves))t.push([e.key,e.value.totalResultMs]);console.table(t)}async set(t){const e=await this.latestSolves;this.latestSolves=(async()=>this.maintainSize(a(t._id,t,e)))()}async delete(t){const e=await this.latestSolves;this.latestSolves=(async()=>this.maintainSize(n(t,e)))()}async kthMostRecent(t){var e;const s=await this.latestSolves;return null!==(e=o(-t-1,s))&&void 0!==e?e:null}async nMostRecent(t){const e=[];let s=0;const n=i(await this.latestSolves);for(const i of n)if(e.push(i),s++,s>=t)break;return e}}function k(t,e){return t.totalResultMs-e.totalResultMs}function z(t){if(t.length<1)return null;var e=0;for(const s of t)e+=s.totalResultMs;return Math.round(e/t.length)}function L(t){if(t.length<3)return null;var e=t.sort(k);const s=Math.ceil(e.length/20);return z(e.slice(s,e.length-s))}function B(t){return t.length<1?null:Math.min.apply(this,t.map(t=>t.totalResultMs))}function E(t){return t.length<1?null:Math.max.apply(this,t.map(t=>t.totalResultMs))}class I{constructor(t,e){C.set(this,{writable:!0,value:void 0}),x.set(this,{writable:!0,value:void 0}),W.set(this,{writable:!0,value:void 0}),N.set(this,{writable:!0,value:[]}),u(this,"name",void 0),u(this,"event",void 0),u(this,"_id",void 0),h(this,C,t),h(this,W,e),this.name=l(this,W).name,this.event=l(this,W).event,this._id=l(this,W)._id,h(this,x,new R(t,l(this,W)._id)),l(this,C).addListener(this.onSyncChange.bind(this))}static async create(t,e,s){return new I(t,await t.createSession({name:e,event:s}))}async onSyncChange(t){for(const e of t)e._deleted||e.sessionID!==this._id?await l(this,x).delete(e._id):await l(this,x).set(e);this.fireStatListeners()}async getStatSnapshot(){const t=await this.nMostRecent(100),e=t.slice(0,12),s=t.slice(0,5),i=t.slice(0,3);return{latest100:t,mean3:i.length<3?null:z(i),avg5:s.length<5?null:L(s),avg12:e.length<12?null:L(e),avg100:t.length<100?null:L(t),best100:B(t),worst100:E(t)}}addStatListener(t){l(this,N).push(t)}removeStatListener(t){for(let e=0;e<l(this,N).length;e++)if(l(this,N)[e]===t)return void h(this,N,l(this,N).slice(0,e).concat(l(this,N).slice(e+1)));throw new Error("Tried to remove a stats listener that wasn't registered!")}async fireStatListeners(){const t=await this.getStatSnapshot();for(const e of l(this,N))e(t)}async add(t){t.sessionID=this._id;const e=await l(this,C).addNewAttempt(t);return l(this,x).set(e),await this.fireStatListeners(),e}async update(t){l(this,C).updateAttempt(t),l(this,x).set(t),await this.fireStatListeners()}async delete(t){await l(this,C).deleteAttempt(t),await l(this,x).delete(t._id),await this.fireStatListeners()}async kthMostRecent(t){return l(this,x).kthMostRecent(t)}async nMostRecent(t){return l(this,x).nMostRecent(t)}async numAttempts(){return l(this,C).sessionNumAttempts(this._id)}async debugPouch(){return l(this,C)}async debugCache(){return l(this,x)}}var C=new WeakMap,x=new WeakMap,W=new WeakMap,N=new WeakMap;exports.TimerDB=class{constructor(){u(this,"storage",void 0),this.storage=new A}startSync(t){this.storage.connectRemoteDB(t.username,t.password)}async getSessions(){return(await this.storage.getAllSessions()).map(t=>new I(this.storage,t))}async createSession(t,e){return await I.create(this.storage,t,e)}};class U{constructor(t,e){F.set(this,{writable:!0,value:void 0}),P.set(this,{writable:!0,value:void 0}),T.set(this,{writable:!0,value:void 0}),q.set(this,{writable:!0,value:[]}),u(this,"name",void 0),u(this,"event",void 0),u(this,"_id",void 0),h(this,F,t),h(this,T,e),this.name=l(this,T).name,this.event=l(this,T).event,this._id=l(this,T)._id,h(this,P,new R(t,l(this,T)._id)),l(this,F).addListener(this.onSyncChange.bind(this))}static async create(t,e,s){return new U(t,await t.createSession({name:e,event:s}))}async onSyncChange(t){for(const e of t)e._deleted||e.sessionID!==this._id?await l(this,P).delete(e._id):await l(this,P).set(e);this.fireStatListeners()}async getStatSnapshot(){const t=await this.nMostRecent(100),e=t.slice(0,12),s=t.slice(0,5),i=t.slice(0,3);return{latest100:t,mean3:i.length<3?null:z(i),avg5:s.length<5?null:L(s),avg12:e.length<12?null:L(e),avg100:t.length<100?null:L(t),best100:B(t),worst100:E(t)}}addStatListener(t){l(this,q).push(t)}removeStatListener(t){for(let e=0;e<l(this,q).length;e++)if(l(this,q)[e]===t)return void h(this,q,l(this,q).slice(0,e).concat(l(this,q).slice(e+1)));throw new Error("Tried to remove a stats listener that wasn't registered!")}async fireStatListeners(){const t=await this.getStatSnapshot();for(const e of l(this,q))e(t)}async add(t){t.sessionID=this._id;const e=await l(this,F).addNewAttempt(t);return l(this,P).set(e),await this.fireStatListeners(),e}async update(t){l(this,F).updateAttempt(t),l(this,P).set(t),await this.fireStatListeners()}async delete(t){await l(this,F).deleteAttempt(t),await l(this,P).delete(t._id),await this.fireStatListeners()}async kthMostRecent(t){return l(this,P).kthMostRecent(t)}async nMostRecent(t){return l(this,P).nMostRecent(t)}async numAttempts(){return l(this,F).sessionNumAttempts(this._id)}async debugPouch(){return l(this,F)}async debugCache(){return l(this,P)}}exports.Session=U;var F=new WeakMap,P=new WeakMap,T=new WeakMap,q=new WeakMap;
