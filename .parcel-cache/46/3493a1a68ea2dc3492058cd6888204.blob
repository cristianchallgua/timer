"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allDocsResponseToAttemptList = allDocsResponseToAttemptList;
exports.allDocsResponseToTimes = allDocsResponseToTimes;
exports.TimerSession = void 0;

var _pouchdb = _interopRequireDefault(require("pouchdb"));

var _pouchdbFind = _interopRequireDefault(require("pouchdb-find"));

var _uuid = require("./uuid");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Add a wrapper so we can remove `allowSyntheticDefaultImports`.
_pouchdb.default.plugin(_pouchdbFind.default);

function allDocsResponseToAttemptList(docs) {
  return docs.rows.filter(row => "totalResultMs" in row.doc).map(row => row.doc);
}

function allDocsResponseToTimes(docs) {
  return allDocsResponseToAttemptList(docs).map(doc => doc.totalResultMs);
}

class TimerSession {
  constructor(name = "session") {
    this.db = new _pouchdb.default(`session_${name}`);
    this.db.createIndex({
      index: {
        fields: ["totalResultMs"]
      }
    });
  }

  startSync(onSyncChange) {
    if (!localStorage.pouchDBUsername || !localStorage.pouchDBPassword) {
      console.info("No CouchDB user!");
      return;
    }

    console.log("Attempting to connect to CouchDB."); // TODO:
    // - Validate username/password.
    // - auth using e.g. cookies

    const url = new URL("https://couchdb.api.cubing.net/");
    url.username = localStorage.pouchDBUsername;
    url.password = localStorage.pouchDBPassword;
    url.pathname = `results-${localStorage.pouchDBUsername}`;
    this.remoteDB = new _pouchdb.default(url.toString());
    this.db.sync(this.remoteDB, {
      live: true,
      retry: true
    }).on('change', onSyncChange).on('error', err => {
      console.log("sync error", err);
    }).catch(err => {
      console.log("sync bad error", err);
    });
  } // Modifies the data to add the ID


  async addNewAttempt(data) {
    const dataWithId = data;
    dataWithId._id = (0, _uuid.newDateUUID)(data.unixDate); // console.log(dataWithId);

    return await this.db.put(dataWithId);
  }

  async extremeTimes(limit, descending = false) {
    return (await this.db.find({
      selector: {
        totalResultMs: {
          $gt: 0
        }
      },
      sort: [{
        "totalResultMs": descending ? "desc" : "asc"
      }],
      limit: 1
    })).docs;
  }

  async bestSuccess() {
    const list = await this.extremeTimes(1);

    if (list.length === 0) {
      return null;
    }

    return list[0];
  }

  async worstSuccess() {
    const list = await this.extremeTimes(1, true);

    if (list.length === 0) {
      return null;
    }

    return list[0];
  } // TODO: this is in reverse order!


  async mostRecentAttempts(limit) {
    return await this.db.allDocs({
      limit: limit,
      descending: true,
      include_docs: true
    }); //.rows.map((row) => row.doc!);
  } // TODO: this is in reverse order!


  async mostRecentAttemptsForEvent(event, limit) {
    // return (await this.db.allDocs({
    //   limit: limit,
    //   descending: true,
    //   include_docs: true,
    // })); //.rows.map((row) => row.doc!);
    return await this.db.find({
      selector: {
        event
      },
      sort: [{
        "_id": "desc"
      }],
      limit: limit
    });
  } // TODO: Remove this and encourate using map/reduce or limited reads.


  async allAttempts() {
    return allDocsResponseToAttemptList(await this.db.allDocs({
      include_docs: true
    }));
  }

}
/******** Types ********/
// export type SessionUUID = UUID;
// export interface SessionData {
//   // Arbitrary user-provided name.
//   name: string;
//   _id: SessionUUID;
//   // Attempts must be in increasing order of Unix date.
//   // If the attempts are out of order, the resulting behaviour is undefined.
//   attempts: AttemptData[]
//   cachedStats?: SessionStats;
//   // TODO: session created and modified date?
// }
// export interface SessionStats {
//   numAttempts: number;
//   best: AttemptReferenceWithTotalResult;
//   worst: AttemptReferenceWithTotalResult;
//   // TODO: average, means?
// }
// export interface AttemptReference {
//   attemptUUID: AttemptUUID;
// }
// export interface AttemptReferenceWithTotalResult extends AttemptReference {
//   totalResult: number;
// }
// export interface AttemptRangeReference {
//   firstAttemptUUID: AttemptUUID;
//   lastAttemptUUID: AttemptUUID;
// }


exports.TimerSession = TimerSession;